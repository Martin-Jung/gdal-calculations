This package enables simple tiled (or untiled if desired) raster calculations (AKA "map algebra") from the commandline or from within your python scripts.

There is a commandline raster calculator:

        Name: gdal_calculate
        Purpose: Perform simple tiled raster calculations (AKA "map algebra")
                 from the commandline

        Notes:
                 Can handle rasters with different extents and coordinate systems
                 as long as they overlap.

                 Cellsizes must be the same.

        Required parameters:
             --calc     : calculation in numpy syntax, rasters specified as using
                          any legal python variable name syntax, band numbers are
                          specified using square brackets (zero based indexing)
             --outfile  : output filepath
             --{*}      : filepaths for raster variables used in --calc
                          e.g. --calc='(someraster[0]+2)*c' --someraster='foo.tif' --c='bar.tif'

        Optional parameters:
             --of            : GDAL format for output file (default "GTiff")')
             --co            : Creation option to the output format driver.
                               Multiple options may be listed.
             --extent        : one of MINOF|INTERSECT|MAXOF|UNION|"xmin ymin xmax ymax"
                               (Default=MINOF)
             --nodata        : handle nodata using masked arrays (Default=False)
                               uses numpy.ma.MaskedArray to handle NoData values
                               MaskedArrays can be much slower...
             --notile        : don't use tiled processing, faster but uses more memory (Default=False)
             --overwrite     : overwrite if required (Default=False)
             --reproject     : reproject if required (Default=False)
                               datasets are projected to the SRS of the first input
                               dataset in an expression
             --resampling    : one of "AVERAGE"|"BILINEAR"|"CUBIC"|"CUBICSPLINE"|
                               "LANCZOS"|"MODE"|"NEAREST"|gdal.GRA_*)
                               (Default="NEAREST")
             --tempdir       : temporary working directory

        Example:
               gdal_calculate --outfile=../testdata/ndvi.tif       \
                    --calc="((nir[3]-red[2].astype(numpy.float32))/(nir[3]+red[2].astype(numpy.float32)))" \
                    --red=../testdata/landsat_utm50.tif  \
                    --nir=../testdata/landsat_geo.tif    \
                    --overwrite --reproject --extent=MAXOF
                    
And a raster calculations library:

    Name: gdal_calculations
    Purpose: GDAL Dataset and Band abstraction for simple tiled raster calculations
             (AKA "map algebra")

    Author: Luke Pinner
    Contributors: Matt Gregory

    Notes:
              Can handle rasters with different extents and coordinate systems
              as long as they overlap.

              Cellsizes must be the same.

    To Do:
            Handle different cellsizes?

    Examples:
        from gdal_calculations import *
        
        Env.extent = [xmin, ymin, xmax, ymax] # Other acceptable values:
                                              #  'INTERSECT' or 'MINOF' (default)
                                              #  'UNION' or 'MAXOF'
        Env.resampling = 'CUBIC'              # Other acceptable values:
                                              #  'NEAREST' (default)
                                              #  'AVERAGE'|'BILINEAR'|'CUBIC'
                                              #  'CUBICSPLINE'|'LANCZOS'|'MODE'
                                              #   gdal.GRA_* constant

        Env.reproject=True  #reproject on the fly if required

        Env.nodata=True  #Use a numpy.ma.MaskedArray to handle NoData values
                          #Note MaskedArrays are much slower...

        Env.overwrite=True

        gdal.UseExceptions()

        ds1=Dataset('../testdata/landsat_utm50.tif')#Projected coordinate system
        ds2=Dataset('../testdata/landsat_geo.tif')  #Geographic coordinate system

        #red=ds1[2].astype(np.float32) #You can use numpy type conversion (is slower)
        red=Float32(ds1[2]) #or use one of the provided type conversion functions (quicker as they use VRT's)
        nir=ds2[3]

        ndvi=(nir-red)/(nir+red)

        #Or in one go
        #ndvi=(ds2[3]-Float32(ds1[2])/(ds2[3]+Float32(ds1[2]))
        ndvi=ndvi.save(r'../testdata/ndvi1.tif')

        #If you want to speed things up... use numexpr!
        #but there are a few limitations...
        import numexpr as ne

        #Must not be tiled for numexpr
        Env.tiled=False

        #No subscripting or methods in the expression
        #red=ds1[2].astype(np.float32)
        red=Float32(ds1[2])
        nir=ds2[3] #Some Int*/UInt* datasets cause segfaults, workaround is cast to Float32

        #Must be same coordinate systems and dimensions
        #The check_extent method will reproject and clip if required
        #This is done using virtual rasters (VRT) so is very quick
        nir,red=nir.check_extent(red)

        expr='(nir-red)/(nir+red)'
        ndvi=ne.evaluate(expr)

        #evaluate returns an ndarray not a Dataset
        #So need to write to a Temporary ArrayDataset
        ndvi=ArrayDataset(ndvi,prototype_ds=nir)
        ndvi=ndvi.save(r'../testdata/ndvi2.tif',options=['compress=LZW','TILED=YES'])

        #Get the raw numpy array data
        for block in red.ReadBlocksAsArray():
            print block.x_off,block.y_off,block.data.shape

        rawdata=red.ReadAsArray()
        print rawdata.shape

